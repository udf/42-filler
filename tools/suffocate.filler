#!/usr/bin/env python3
import re
import sys
import functools
import time

printd = functools.partial(print, file=sys.stderr)


def read_map():
	m = re.match(r'^Plateau (\d+) (\d+):', input())
	height = int(m.group(1))
	width = int(m.group(2))

	# first line is the ruler
	input()

	map_data = []
	for i in range(height):
		line = re.match(r'^\d+\s+(.+)$', input()).group(1)
		if len(line) != width:
			raise RuntimeError("wrong line width in map")
		map_data.append(line.lower())
	return map_data


def read_piece():
	m = re.match(r'^Piece (\d+) (\d+):', input())
	height = int(m.group(1))
	width = int(m.group(2))

	piece_data = []
	for i in range(height):
		line = input()
		if len(line) != width:
			raise RuntimeError("wrong line width in piece")
		piece_data.append(line)
	return piece_data


def can_place(map_data, piece_data, oy, ox):
	m_h, m_w = len(map_data), len(map_data[0])
	p_h, p_w = len(piece_data), len(piece_data[0])

	if oy + p_h >= m_h or ox + p_w >= m_w:
		return False
	num_overlaps = 0
	for y, line in enumerate(piece_data):
		for x, tile in enumerate(line):
			m_tile = map_data[(y + oy) % m_h][(x + ox) % m_w]
			if tile == '.':
				continue
			if m_tile == E_CHR:
				return False
			if m_tile == P_CHR:
				num_overlaps += 1
				if num_overlaps > 1:
					return False
	return num_overlaps == 1


def trim_piece(piece_data):
	p_h, p_w = len(piece_data), len(piece_data[0])

	# top:bottom
	for y in range(p_h):
		if not all(c == '.' for c in piece_data[y]):
			break
	y_start = y
	for y in reversed(range(p_h)):
		if not all(c == '.' for c in piece_data[y]):
			break
	y_end = y + 1
	piece_data = piece_data[y_start:y_end]
	p_h = y_end - y_start

	# left:right
	for x in range(p_w):
		if not all(piece_data[y][x] == '.' for y in range(p_h)):
			break
	x_start = x
	for x in reversed(range(p_w)):
		if not all(piece_data[y][x] == '.' for y in range(p_h)):
			break
	x_end = x + 1
	for y, line in enumerate(piece_data):
		piece_data[y] = line[x_start:x_end]
	return piece_data, y_start, x_start


def enum_moves(map_data, piece_data):
	m_h, m_w = len(map_data), len(map_data[0])
	piece_data, y_shift, x_shift = trim_piece(piece_data)
	for y in range(m_h):
		for x in range(m_w):
			if can_place(map_data, piece_data, y, x):
				yield y - y_shift, x - x_shift


def iter_sqperi(size, y, x):
	# ABBBC
	# H   D
	# H o D
	# H   D
	# GFFFE
	# A-B
	for i in range(-size, size):
		yield -size + y, i + x
	# C-D
	for i in range(-size, size):
		yield i + y, size + x
	# E-F
	for i in range(-size, size):
		yield size + y, -i + x
	# G-H
	for i in range(-size, size):
		yield -i + y, -size + x


def closest_enemy(ys, xs, map_data):
	m_h, m_w = len(map_data), len(map_data[0])

	size = 1
	while 1:
		for y, x in iter_sqperi(size, ys, xs):
			if 0 <= x < m_w and 0 <= y < m_h and map_data[y][x] == E_CHR:
				return y, x, size
		size += 1


def center_of_mass(piece_data):
	c_y, c_x = 0, 0
	num_tiles = 0
	for y, line in enumerate(piece_data):
		for x, tile in enumerate(line):
			if tile == '*':
				c_x += x
				c_y += y
				num_tiles += 1
	return c_y // num_tiles, c_x // num_tiles


def place(map_data, piece_data):
	best = (0, 0, -999999)
	c_y, c_x = center_of_mass(piece_data)
	for y, x in enum_moves(map_data, piece_data):
		score = 0
		score -= closest_enemy(y + c_y, x + c_x, map_data)[2]
		if score > best[2]:
			best = (y, x, score)
	return f'{best[0]} {best[1]}'


# set up player number
PLAYER_NUMBER = int(re.match(r'^\$\$\$ exec p(\d)', input()).group(1))
P_CHR = 'o'
E_CHR = 'x'
if PLAYER_NUMBER == 2:
	P_CHR, E_CHR = E_CHR, P_CHR

while 1:
	try:
		map_data = read_map()
		piece_data = read_piece()
	except EOFError:
		break
	print(place(map_data, piece_data))